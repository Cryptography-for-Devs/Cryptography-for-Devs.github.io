<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Slow them down</title>

    <!-- PostHog Integration Start -->
    <script>
        !function (t, e) { var o, n, p, r; e.__SV || (window.posthog = e, e._i = [], e.init = function (i, s, a) { function g(t, e) { var o = e.split("."); 2 == o.length && (t = t[o[0]], e = o[1]), t[e] = function () { t.push([e].concat(Array.prototype.slice.call(arguments, 0))) } } (p = t.createElement("script")).type = "text/javascript", p.async = !0, p.src = s.api_host.replace(".i.posthog.com", "-assets.i.posthog.com") + "/static/array.js", (r = t.getElementsByTagName("script")[0]).parentNode.insertBefore(p, r); var u = e; for (void 0 !== a ? u = e[a] = [] : a = "posthog", u.people = u.people || [], u.toString = function (t) { var e = "posthog"; return "posthog" !== a && (e += "." + a), t || (e += " (stub)"), e }, u.people.toString = function () { return u.toString(1) + ".people (stub)" }, o = "capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys onSessionId".split(" "), n = 0; n < o.length; n++)g(u, o[n]); e._i.push([i, s, a]) }, e.__SV = 1) }(document, window.posthog || []);
        posthog.init('phc_yHP5sNNdtvQqVh1IjhFKe30UMexVa7d5j3QzaHvRUqi', { api_host: 'https://us.i.posthog.com' })
    </script>
    <!-- PostHog Integration End -->


    <!-- sentry error monitoring start -->
    <script src="https://js.sentry-cdn.com/3a27f38f284bb38b1a83d2f74fdbe425.min.js" crossorigin="anonymous"></script>
    <!-- sentry error monitoring end -->


    <link rel="stylesheet" href="../styles/style.css">

    <!-- Medium zoom! -->
    <script src="https://unpkg.com/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script>
    <script src="../scripts/medium-zoom.js"></script>

</head>

<body>

    <script src="../components/nav-bar.js"></script>
    <main>
        <h1><span style="color: #ccc;">6. </span>PBKDF-2: üêå slowing down
            <br>
            <span style="font-size: 0.4em; font-weight: normal; color: rgba(0, 0, 0, 0.5);">
                Author:
                <img src="../twitter-logo.svg" alt="twitter logo"
                    style="border: none; width: 25px; vertical-align: middle;">
                <a href="https://twitter.com/vkwebdev" target="_blank">
                    @vkwebdev
                </a>
            </span>
        </h1>

        <h2>The advent of GPUs</h2>

        <p>When Nvidia launched the world's first Graphics Processing Unit in 1999 -- GeForce 256, they set the stage
            for
            future growth of parallel processing.</p>

        <p>Post 2008 to today's 2020s, the processing capabilities of these GPUs have grown exponentially. Plus their
            cost
            have significantly decreased over time.</p>

        <p>Back in early 2000s, if one had to brute force a password, they would use a CPU which had a few cores.
            So, only a few parallel password and its hash combination could be calculated at a time.</p>

        <p>The modern GPUs have thousands of cores. If we take a look at Nvidia RTX 4090, it can calculate around
            <strong>19 billion SHA-256 hashes per
                second</strong>. Attackers realised this parallel processing power, they could now brute-force passwords
            at astonishingly
            fast rate!
        </p>

        <figure>
            <img data-zoomable src="power-of-gpus.svg" alt="The parallel processing power of GPUs!">
            <figcaption>The parallel processing power of GPUs!</figcaption>
        </figure>

        <p>
            If the attacker has to crack a salted password, he takes the salt from the db, and
            then
            computes around <strong>100 - 150 billions of <code>SHA-256(password + salt)</code> combinations per
                second</strong>
            because attackers have
            multiple GPUs in their password cracking rig. In a few days, most of the passwords will be cracked
            except for the larger and complex ones like passwords that are greater than 8 characters.
        </p>

        <p>This is a <strong>serious security risk</strong>. If a hacker with 5 to 10 high-end GPUs can cause this much
            damage,
            imagine
            if a very well-funded
            entity like a large cyber terrorist group gets access of hundreds of powerful GPUs, the damage can be
            disastrous!
        </p>

        <h2>PBKDF-2!</h2>

        <p><strong>Password based key derivation function 2 (PBKDF-2)</strong> is a key derivation
            function designed for storing user passwords safely.</p>

        <p>A <strong>key derivation function (KDF)</strong> was made to derive one or more keys from a master key. The
            derived keys can differ in their key length.</p>

        <pre>
                Let's imagine our master key is "staplehorse" and we want to derive 
                two keys from this master key.
    
                The first key we will use it as our database's password.

                The second key we will use for our PayPal account.
    
    
                    master key     message    key length in bytes  
                        üëá           üëá          üëá
                KDF("staplehorse", "db password", 8) = 120d50e36d1f290c
    
                
                    master key     message    key length in bytes  
                        üëá            üëá              üëá
                KDF("staplehorse", "paypal password", 18) = 9r0f50e46d2xc90ci8317fd38et2az23qw11
    
            </pre>

        <p><strong>The key derivation function uses a
                psuedorandom
                function (PRF)</strong> internally to generate a new key when given the
            <code>master key</code> and the <code>message</code>
            as inputs.
        </p>

        <p> One of the most popular psuedorandom function is -- <strong>HMAC (hash based message authentication
                code).</strong>
            Internally the HMAC
            algorithm uses a cryptographically secure hash function like SHA-256. The HMAC algorithm is known as a
            <strong>keyed hash function</strong> because it utilizes a hash function with two inputs, first the message
            and second <strong>the key</strong>. If the HMAC uses
            SHA-256, it will be called HMAC-SHA-256.
        </p>

        <pre>
            Let's see how a KDF (key derivation function) will work.

                    master key     message    key length in bytes  
                        üëá           üëá          üëá
                KDF("staplehorse", "db password", 8) = 120d50e36d1f290c
                 |
                 |
                 |-------> HMAC-SHA-256("staplehorse", "db password")
    
                The KDF passes master key and message to the HMAC-SHA-256.
                
                Then the returned value of HMAC-SHA-256 will be trimmed to match the input key length
                which is 8 bytes in this case.
        </pre>

        <p>Let us do a quick recap! A <strong>key derivation function uses a psuedorandom function</strong> to
            derive many keys
            from
            a master key.</p>

        <p>Now, <strong>PBKDF-2 is a key derivation function that is specifically designed for the use case of
                handling user
                passwords.</strong> It takes the <code>user's password, salt and iterations</code> as an input. If we
            don't provide
            the salt by ourselves, the algorithm generates a salt by its own. Then it passes the user's password and the
            salt to the underlying psuedorandom function.</p>

        <p>We told that PBKDF-2 accepted as an input <code><strong>iterations</strong></code>. Iterations is the
            number of times the input password and the salt goes through the underlying psuedorandom function.
        </p>

        <p>
            The number of iterations is said to be the <strong>work
                factor</strong> -- higher the number of iterations, more work is required to be done by the
            processor before giving the final output.
        </p>

        <p>Let us look at a practical example to understand how all this saves us from attackers using GPUs.</p>

        <pre>
            In Django, User.objects.create_user is used to create a user.

            User.objects.create_user("john", "lennon@thebeatles.com", "johnpassword")
            will create a user named "john", with the email "lennon@thebeatles.com"
            and password "johnpassword".

            The above password gets sent to the make_password() function which generates
            a salt and passes the password and salt to the pbkdf2 function which 
            uses HMAC-SHA-256 as its psuedorandom function.

            Django saves the password as a string to db in the following form:
            &lt;algorithm&gt;$&lt;iterations&gt;$&lt;salt&gt;$&lt;hash&gt;

            hash is the final output of PBKDF-2.

            An example password would be (added space between $ for readability):
            pbkdf2_sha256 $ 600000 $ BHz2LaFrMrXt $ VYlU5EBfFTqErm7fo/rjd67mMiYtmAdFoXDR7ueOUxM=
        </pre>

        <p>The <code>iterations</code> count in the above example is 600,000. It means that when <code>pbkdf2</code>
            function was
            called, it ran the underlying psuedorandom function that is HMAC-SHA-256, 600,000 times. This results in a
            <strong>dramatic
                slow
                down for the brute-force process of password crackers using GPUs.</strong>
        </p>

        <p>Let us take a situation where an attacker tries to brute-force a password using
            Nvidia RTX 4090. We will compare <strong>SHA-256 salted password hash vs PBKDF-2</strong>.</p>

        <pre>
        Let us assume we are cracking a 11 character password.
        The attacker as always has access to the salt. 
        He now just needs to brute-force all possible password combinations. 
        
        Let us assume our character set to be just 26 lowercase characters.
        Total possible password combinations will be 26 to the power 11: 
        26^11 = 3,670,344,486,987,776 possible password combinations.



        A NVIDIA RTX 4090 can calculate for SHA-256: 19 billion hashes per second
        
        Attacker will run:  sha-256("possible-password-1" + "the-salt")
                            sha-256("possible-password-2" + "the-salt")
                            sha-256("possible-password-3" + "the-salt") and so on...
        
        Time to crack for SHA-256 on NVIDIA RTX 4090: 
        3,670,344,486,987,776 √∑ 19 billion ‚âà 193,176 seconds ‚âà 2 days.



        A NVIDIA RTX 4090 can calculate for PBKDF2 (600K iterations): 14,000 hashes per second

        Attacker will run:  PBKDF-2("possible-password-1", "the-salt", 600000)
                            PBKDF-2("possible-password-2", "the-salt", 600000)
                            PBKDF-2("possible-password-3", "the-salt", 600000) and so on...

        Time to crack for PBKDF2 (600K iterations): 
        3,670,344,486,987,776 √∑ 14000
        ‚âà 2.6 * 10^11 seconds
        ‚âà 8,245 years!
    </pre>

        <p>To crack <code>greatapples</code> if we just used SHA-256 hashing, attacker could crack it in around 2 days.
            But with PBKDF-2, it'll take 8,245 years. That's the power of PBKDF-2 (the power of its underlying
            psuedorandom function's <strong>iterations</strong>). So, PBKDF-2 ultimately helped us
            <strong>defend against powerful GPU-based
                brute-force attacks!</strong>
        </p>

        <hr>

        <p>This marks the end of our first series of lessons, if you have made it up till here, very very
            Congratulations. ü•≥<br><br>
            You are a shining star ‚≠ê! <a href="mailto:vivekmittalagrawal@gmail.com">Send
                me an email</a> and I will love to talk to you over a video call to listen to your experience so far.
        </p>

        <p>
            I will post updates on <a href="https://twitter.com/vkwebdev" target="_blank">my Twitter</a> when
            the second part of the course gets released.
            <br><br>
            It all will remain free, forever :)
        </p>

        <hr>

        <!-- Feedback form START -->
        <p>üí™ Requesting you to <a target="_blank" href="https://forms.gle/7SQojkZ1ub4PXEjr7">fill a
                short
                feedback
                form</a> in the celebration of PBKDF-2's success in defeating the attackers!
        </p>
        <!-- Feedback form END -->
    </main>

    <script src="../components/lesson-map.js"></script>

</body>

</html>
