<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>TLS</title>

    <!-- PostHog Integration Start -->
    <script>
        !function (t, e) { var o, n, p, r; e.__SV || (window.posthog = e, e._i = [], e.init = function (i, s, a) { function g(t, e) { var o = e.split("."); 2 == o.length && (t = t[o[0]], e = o[1]), t[e] = function () { t.push([e].concat(Array.prototype.slice.call(arguments, 0))) } } (p = t.createElement("script")).type = "text/javascript", p.async = !0, p.src = s.api_host.replace(".i.posthog.com", "-assets.i.posthog.com") + "/static/array.js", (r = t.getElementsByTagName("script")[0]).parentNode.insertBefore(p, r); var u = e; for (void 0 !== a ? u = e[a] = [] : a = "posthog", u.people = u.people || [], u.toString = function (t) { var e = "posthog"; return "posthog" !== a && (e += "." + a), t || (e += " (stub)"), e }, u.people.toString = function () { return u.toString(1) + ".people (stub)" }, o = "capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys onSessionId".split(" "), n = 0; n < o.length; n++)g(u, o[n]); e._i.push([i, s, a]) }, e.__SV = 1) }(document, window.posthog || []);
        posthog.init('phc_yHP5sNNdtvQqVh1IjhFKe30UMexVa7d5j3QzaHvRUqi', { api_host: 'https://us.i.posthog.com' })
    </script>
    <!-- PostHog Integration End -->

    <!-- sentry error monitoring start -->
    <script src="https://js.sentry-cdn.com/3a27f38f284bb38b1a83d2f74fdbe425.min.js" crossorigin="anonymous"></script>
    <!-- sentry error monitoring end -->


    <!-- Medium zoom! -->
    <script src="https://unpkg.com/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script>
    <script src="../scripts/medium-zoom.js"></script>

    <link rel="stylesheet" href="../styles/style.css">

    <style>
        figure img {
            box-shadow: 0 0 14px rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .client-send,
        .server-send {
            padding: 10px 20px;
            border-radius: 20px;
            margin-bottom: 10px;
            max-width: 85%;
            display: flex;
            align-items: center;
            border: 1px solid rgba(0, 0, 0, 0.6);
        }

        .client-send {
            background-color: #f0f8ff;
            justify-content: space-between;
        }

        .server-send {
            margin-left: auto;
            background-color: #ffa60096;
            justify-content: space-between;
        }

        .client-send p,
        .server-send p {
            margin: 0;
        }

        .client-send img,
        .server-send img {
            width: 32px;
        }

        .client-send img {
            margin-left: 12px;
        }

        .server-send img {
            margin-right: 12px;
        }

        /* Styling to make expand look better */
        details {
            padding: 10px;
        }

        summary {
            cursor: pointer;
            background-color: #f0f0f0;
            padding: 10px;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <script src="../components/nav-bar.js"></script>

    <main>
        <h1>
            <span style="color: #ccc;">9. </span>
            TLS
            <br>
            <span style="font-size: 0.4em; font-weight: normal; color: rgba(0, 0, 0, 0.5);">
                Author:
                <img src="../twitter-logo.svg" alt="twitter logo"
                    style="border: none; width: 25px; vertical-align: middle;">
                <a href="https://twitter.com/vkwebdev" target="_blank">
                    @vkwebdev
                </a>
            </span>
        </h1>

        <p>In this lesson we will understand how TLS actually works. We will uncover stuff step by step.</p>

        <p>We assume that you have studied our
            previous two lessons. The one on Diffie Hellman key exchange and the one on RSA public key algorithm.</p>

        <h2>The final attack that we are going to defend!</h2>

        <p>In the previous lesson, we saw how RSA digital signature helped us defend against the Man in the Middle
            attack during Diffie Hellman key exchange process.</p>

        <p>To recap quickly: Bug signed his message with his private key and distributed his public key to everybody.
            When Ant received Bug's message, he verified the signature with Bug's public key. If the verification passed
            then it meant that the message was not altered during transmission and the message is from Bug only.</p>

        <p>There's a possibility of an attack here. And its going to be the last attack. After this Ant and Bug will
            talk securely forever.</p>

        <p>Let us take a situation where the attacker would have
            intercepted Bug's public key and replaced Bug's public key with his own public key (that is, the attacker's
            public key) and then sent
            it to
            Ant.</p>

        <figure>
            <img data-zoomable src="public-key-intercepted.png"
                alt="Illustration of -- Bug's public key intercepted and replaced by Man in the Middle's public key!">
            <figcaption>
                Bug's public key intercepted and replaced by Man in the Middle's public key!
            </figcaption>
        </figure>

        <p>Ant would have thought that its Bug's public key because there's no verification step here to make sure that
            Ant has received the public key from Bug. This missing step is really dangerous, let us see how.</p>

        <p>All messages that
            Bug would sent to Ant will
            get intercepted by the attacker. The attacker will modify the message, and <strong>sign the message with his
                own
                private key.</strong></p>

        <p>Now the interesting part -- when Ant will verify the signature, the verification will pass because
            <strong>Ant is verifying the signature
                with
                attacker's public key not with Bug's public key.</strong>
        </p>

        <p>When the verification passes, Ant thinks that the message is truely from Bug. But that ain't the case. The
            attacker is modifying and re-signing the messages with his own private key. Since, Ant has attacker's public
            key the signature verification is getting passed.</p>

        <p>This is again the Man in the Middle attack! The attacker that is our man in the middle of the conversation is
            able to modify the messages without Ant or Bug realising it.</p>

        <p>
            How can Ant <strong>trust the public key</strong> that he has received? How he can make sure that the public
            key is actually from Bug and not from someone acting on Bug's behalf?</p>

        <h2>The missing step is: Chain of Trust</h2>

        <p>During Diffie Hellman key exchange, we know that, Bug signed his message with his private key and sends his
            public key to Ant.</p>

        <p>To understand this part, let us assume
            that Ant is the client
            (the browser). And Bug is our server. Bug is the server of
            <code>news.ycombinator.com (Hacker news)</code>.
        </p>

        <p>Our browser has received public key from the hacker news server. Now the problem is, how can the browser
            <strong>trust</strong> this public key?
        </p>

        <p>How can the browser make sure that this public key actually <strong>belongs to the hacker news
                server</strong> and not to someone in the middle...?</p>

        <p>This problem is solved with the help of two entities called as -- <strong>Intermediate Certificate Authority
                (Intermediate CA)</strong> and <strong>Root Certificate Authority (Root CA).</strong></p>

        <p>The umbrella term for these two entities is simply -- Certificate Authority. Imagine it like, Certificate
            Authority
            is the company and it has two employees under this company named as Intermediate CA and Root CA. The company
            has to manage and
            take care of these two employees.</p>

        <p>As we will move forward, it all will make sense
            intuitively. I hope :)</p>

        <p>The task of the Intermediate CA is to verify that the one who is claiming to be the owner of
            <code>news.ycombinator.com</code> has control over the server of
            <code>news.ycombinator.com</code>.
        </p>

        <p>
            Once
            this verification is completed, the Intermediate CA signs with its private key the <strong>Public Key
                Certificate</strong> of
            the
            server. It's also called as TLS certificate.
        </p>

        <p> This
            public key certificate as the name suggests has the public key of the server.</p>

        <p>Intermediate CA has its own public key certificate which contains the public key of the Intermediate CA.</p>

        <p>Now, when our browser requests the public key from the server. The server sends two things -- the server's
            public key certificate and Intermediate CA's public key certificate.</p>

        <figure>
            <img data-zoomable src="hackernews-chain-of-trust.png" alt="Hacker news certificate's chain of trust.">
            <figcaption>
                Hacker news -- chain of trust.
            </figcaption>
        </figure>

        <p>When the browser receives the server's public key certificate and Intermedia CA's public key certificate, the
            browser looks at the server's certificate, and sees that the server's certificate is signed by the
            Intermediate CA.</p>

        <p>If you look at the image above, you will see that, the hacker news server certificate is signed by (or issued
            by) the Intermediate CA (Let's Encrypt E5). The Intermediate CA's public key certificate is signed by the
            Root CA.</p>

        <p>The browser traverses this path: server certificate to intermediate CA certificate to root CA certificate.
        </p>

        <p><strong>Every browser has a pre-populated list of Root CA's public keys that it can trust.</strong> The
            browser developers
            populate this list. And keep this list updated. For example, <a
                href="https://chromium.googlesource.com/chromium/src/+/main/net/data/ssl/chrome_root_store/root_store.md"
                target="_blank">here's
                the Chrome root store</a>.</p>

        <p>This pre-populated list of Root CAs public keys in the browser is called as <strong>root store.</strong></p>

        <p>The
            browser looks at the
            Root CA's public key certificate, extracts the Root CA's public key from it and then it searches in its root
            store.</p>

        <p>The browser proceeds to the next step, <strong>only if the Root CA is at the end of the chain and is found in
                the
                root store.</strong></p>

        <p>Once the browser has verified the Root CA. The browser takes the Root CA's public key from its certificate
            and verifies the
            Intermediate CA's public key
            certificate
            signature.
            Then it takes the Intermediate CA's public key and verifies the server public key certificate signature.</p>

        <p>Once the signature verification steps passes then it means that the server's public key certificate is
            valid. And <strong>the public key contained in the server certificate belongs only to the hacker news
                server.</strong></p>

        <p>Btw, why was it so important to verify the Root CA...?</p>

        <p>See, the attacker can modify the server certificate and the intermediate CA certificate as they are sent over
            the network. But the Root CA certificate is in-built into the browser. So there's no way for an attacker to
            touch the Root CAs certificates.</p>

        <p>So, once we verify the Root CA, any modifications to the intermediate CA certificate and server certificate
            will be caught during signature verification.</p>

        <p>Hence, the most important thing in the chain is to -- have a <strong>trusted Root CA</strong> at the end of
            the chain.</p>

        <p>So our takeaway with all of this is -- with the help of chain of trust, the browser verifies that the public
            key indeed
            belongs to the server only
            not to anybody else!</p>

        <p>One last thing: we developers don't have to deal with any of this. This all happens automatically in the TLS
            handshake
            process. A developer just needs to install a TLS public key certificate in its server with help of a CA, for
            example, by using <a href="https://letsencrypt.org" target="_blank">Let's Encrypt CA</a>.</p>

        <h2>Finale -- The TLS Handshake 🤝</h2>

        <p>Finally, Ant and Bug will be able to talk securely. They will have an encrypted communication without
            any worries. Because we have arrived at the pinnacle of secure communication -- <strong>Transport Layer
                Security (TLS).</strong></p>

        <p>TLS handshake is the process that makes the client and server exchange the secret key with help of Diffie
            Hellman key exchange. See the aim here is to understand the handshake process intuitively.</p>

        <figure>
            <img data-zoomable src="tls-simple-handshake.png" alt="Illustration of simple TLS handshake.">
            <figcaption>
                TLS handshake for intuitive understanding.
            </figcaption>
        </figure>

        <p>We will learn what happens at each step
            and you will see that everything that we have studied so far -- symmetric encryption, cryptographic hashing,
            RSA asymmetric cryptography, digital signatures, Diffie Hellman key exchange. All this will come together to
            make TLS happen!
        </p>

        <div class="client-send">
            <p>
                The TLS handshake starts with the client saying "Hello" to the server.
            </p>
        </div>

        <div class="server-send">

            <p>
                The server on receiving the "Hello" selects a <code>base, modulus and private number</code>. Then
                it calculates the public number for Diffie Hellman key exchange.

                <br><br>

                The public number is signed with the server's private key and then its
                sent
                along with the server certificate and Intermediate CA's certificate.
            </p>
        </div>

        <div class="client-send">
            <p>
                The client verifies the certificate using Chain of Trust.

                <br><br>

                The RSA signature of the server's Diffie Hellman public number is verified.

                <br><br>

                The client uses its private number and the server's public number to arrive at the
                <strong>shared
                    secret key 🔑.</strong>

                <br><br>

                Then client sends its Diffie Hellman public number with a HMAC of all the previous messages and a
                "Finished" string.

                <br><br>

                The HMAC (Hash Based Message Authentication Code) takes in two inputs. Both are required. The first
                input is the
                Diffie
                Hellman secret key that the client calculated and the second input is all the message history between
                the client and server so far. The HMAC produces a hash value by combining those two inputs.

                <br><br>

                <strong>This stops the attacker from
                    modifying this message.</strong> Because if the attacker changes the message, the HMAC verification
                will fail on the server end. And also the attacker cannot generate a new HMAC because it doesn't have
                access
                to the client's Diffie Hellman secret key (a required input of the HMAC function)!
            </p>

        </div>

        <div class="server-send">

            <p>
                The server calculates the <strong>shared secret key 🔑</strong> using the client's Diffie Hellman public
                number that it just received.

                <br><br>

                Then the server verifies the client message's HMAC. It verifies it by hashing all the previous
                messages along with the Diffie Hellman secret key that the server just calculated.

                <br><br>

                <strong>This
                    verification proves that
                    the secret
                    key that server has calculated is the same as the client's one.</strong>

                <br><br>
                Server sends a "Finished" message to the client along with the HMAC of all the
                previous messages just like the client did.
            </p>
        </div>

        <div class="client-send">

            <p>The client verifies the HMAC that it received from the server by hashing its own message history
                along
                with the
                Diffie Hellman secret key that the client has. This proves that the server and client both have the same
                message
                history. This proves that the attacker has <strong>not modified anything in between.</strong></p>

        </div>

        <p>Now, the client and the server are ready with their shared secret key 🔑!</p>

        <p>
            All future messages <strong>will now be encrypted</strong> using a symmetric encryption algorithm that the
            client and server support. The shared secret key will be used as the encryption key.</p>
        <p>
            Since, only the client and the server have the shared secret key, their communication is securely encrypted!
        </p>

        <p>We are finally being able to talk securely. Now, let the client and server enjoy the talking. Let us move on
            ;)</p>

        <h3>TLS or SSL ... ?</h3>

        <figure>
            <img width="60%" data-zoomable src="old-web-google.png" alt="google.stanford.edu in netscape navigator 4">
            <figcaption>
                Google on Netscape Navigator 4. Emulator: <a href="https://oldweb.today"
                    target="_blank">https://oldweb.today</a>.
            </figcaption>
        </figure>

        <p>Before TLS came around, Netscape developed Secure Sockets Layer (SSL) around 1995 to have encrypted
            communication between a client and
            a server. It was inspired from Secure Network
            Programming (SNP) which
            was led by Simon S. Lam in 1993.</p>

        <p>SSL 1.0 and SSL 2.0 had many security flaws. Then SSL 3.0 stayed for some time. Finally, TLS 1.0 came around
            with improved security in 1999. But with time, some possible attacks made us to shift to TLS 1.1 then TLS
            1.2 and
            the latest TLS 1.3.</p>

        <p>Only TLS 1.2 and TLS 1.3 are safe to use today. Rest all are deprecated.</p>

        <p>So, today when you hear someone talk about SSL, they are reffering to TLS 1.2 or TLS 1.3 ;)</p>

        <h3>HTTPS ... ?</h3>
        <figure>
            <img width="20%" data-zoomable src="https://upload.wikimedia.org/wikipedia/commons/d/da/Internet2.jpg"
                alt="URL beginning with the HTTPS scheme and the WWW domain name label">
            <figcaption>
                URL beginning with HTTPS.
            </figcaption>
        </figure>

        <p>HTTP (HyperText Transfer Protocol) is the <code>request-reponse</code> protocol of the Web. It works in a
            client-server environment. When you open
            GitHub.com, your web browser (the client) sends a GET request to GitHub's server. The GitHub server program
            processes your request and returns a response. The response can be a HTML file, or JSON or any text.</p>

        <p><strong>HTTPS (HyperText Transfer Protocol Secure)</strong> is the HTTP protocol <strong>running with
                TLS.</strong> So when you see HTTPS in the URL, it means that the communication between your browser and
            the server is encrypted with TLS.
        </p>


    </main>
    More than 85% of websites of all the Internet now run on TLS. A big thanks to the <a href="https://letsencrypt.org/"
        target="_blank">Let's Encrypt</a> initiative.
    <h2>TO DO: add credits</h2>
    <h2>TO DO: email and thank xarbgs for tls Illustration</h2>
    <script src="../components/lesson-map.js"></script>
</body>

</html>
